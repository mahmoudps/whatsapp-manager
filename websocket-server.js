#!/usr/bin/env node

/**
 * WebSocket Server ŸÖÿ≠ÿ≥ŸÜ ŸÑŸÄ WhatsApp Manager
 * ŸäÿØÿπŸÖ Socket.IO Ÿà ws ŸÖÿπ Ubuntu 24
 * ÿßŸÑÿ•ÿµÿØÿßÿ± 8.0.0
 */

require("dotenv").config()
const { createServer } = require("http")
const { Server } = require("socket.io")
const WebSocket = require("ws")
const express = require("express")
const cors = require("cors")
const helmet = require("helmet")
const compression = require("compression")
const jwt = require("jsonwebtoken")

// ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ®Ÿäÿ¶ÿ©
const PORT = process.env.WEBSOCKET_PORT || 3001
const NODE_ENV = process.env.NODE_ENV || "development"
const FRONTEND_URL = process.env.FRONTEND_URL || "http://localhost:3000"

let JWT_SECRET, JWT_EXPIRES_IN
try {
  ;({ JWT_SECRET, JWT_EXPIRES_IN } = require("./lib/config"))
} catch (err) {
  JWT_SECRET = process.env.JWT_SECRET || "fallback-secret-key-change-in-production"
  JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || "24h"
}

// Validate JWT_SECRET
if (!JWT_SECRET) {
  console.error("‚ùå JWT_SECRET is not defined!")
  process.exit(1)
}

if (JWT_SECRET === "fallback-secret-key-change-in-production" && process.env.NODE_ENV === "production") {
  console.error("‚ùå Please set a secure JWT_SECRET in production!")
  process.exit(1)
}

console.log("üöÄ Starting WhatsApp Manager WebSocket Server v8.0.0")
console.log("üêß Ubuntu 24.04 LTS Support: ‚úÖ")
console.log("üåê Environment:", NODE_ENV)
console.log("üì° Port:", PORT)
console.log("üîó Frontend URL:", FRONTEND_URL)

// ÿ•ÿπÿØÿßÿØ Express
const app = express()
const server = createServer(app)

// ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ
app.use(
  helmet({
    crossOriginEmbedderPolicy: false,
    contentSecurityPolicy: false,
  }),
)

app.use(compression())
app.use(
  cors({
    origin: [FRONTEND_URL, "http://localhost:3000", "https://localhost:3000"],
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"],
  }),
)

app.use(express.json({ limit: "10mb" }))

// ÿ•ÿπÿØÿßÿØ Socket.IO ŸÖÿπ ÿØÿπŸÖ Ubuntu 24
const io = new Server(server, {
  cors: {
    origin: [FRONTEND_URL, "http://localhost:3000", "https://localhost:3000"],
    methods: ["GET", "POST"],
    credentials: true,
  },
  transports: ["websocket", "polling"],
  allowEIO3: true,
  pingTimeout: 60000,
  pingInterval: 25000,
  upgradeTimeout: 30000,
  maxHttpBufferSize: 1e8, // 100MB
})

// ÿ•ÿπÿØÿßÿØ WebSocket Server ÿßŸÑÿ™ŸÇŸÑŸäÿØŸä ŸÑŸÑÿ™ŸàÿßŸÅŸÇ
const wss = new WebSocket.Server({
  server,
  path: "/ws",
  perMessageDeflate: {
    zlibDeflateOptions: {
      level: 3,
      chunkSize: 1024,
    },
    threshold: 1024,
    concurrencyLimit: 10,
    clientMaxWindow: 13,
    serverMaxWindow: 13,
    serverMaxNoContextTakeover: false,
    clientMaxNoContextTakeover: false,
  },
})

// ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ
const connectedClients = new Map()
const deviceStatuses = new Map()
const systemStats = {
  startTime: new Date(),
  totalConnections: 0,
  activeConnections: 0,
  messagesProcessed: 0,
  errors: 0,
  version: "8.0.0",
  platform: process.platform,
  nodeVersion: process.version,
}

// ÿØŸàÿßŸÑ ŸÖÿ≥ÿßÿπÿØÿ©
function generateClientId() {
  return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

function verifyToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET)
  } catch (error) {
    return null
  }
}

function broadcastToAll(event, data) {
  const message = {
    event,
    data,
    timestamp: new Date().toISOString(),
  }

  // ÿ•ÿ±ÿ≥ÿßŸÑ ÿπÿ®ÿ± Socket.IO
  io.emit(event, data)

  // ÿ•ÿ±ÿ≥ÿßŸÑ ÿπÿ®ÿ± WebSocket ÿßŸÑÿ™ŸÇŸÑŸäÿØŸä
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      try {
        client.send(JSON.stringify(message))
      } catch (error) {
        console.error("Error broadcasting to WebSocket client:", error)
        systemStats.errors++
      }
    }
  })

  systemStats.messagesProcessed++
}

function broadcastToDevice(deviceId, event, data) {
  const message = {
    event,
    data,
    deviceId,
    timestamp: new Date().toISOString(),
  }

  // ÿ•ÿ±ÿ≥ÿßŸÑ ÿπÿ®ÿ± Socket.IO
  io.to(`device_${deviceId}`).emit(event, data)

  // ÿ•ÿ±ÿ≥ÿßŸÑ ÿπÿ®ÿ± WebSocket ÿßŸÑÿ™ŸÇŸÑŸäÿØŸä
  connectedClients.forEach((clientInfo, clientId) => {
    if (clientInfo.deviceId === deviceId && clientInfo.ws && clientInfo.ws.readyState === WebSocket.OPEN) {
      try {
        clientInfo.ws.send(JSON.stringify(message))
      } catch (error) {
        console.error(`Error sending to device ${deviceId}:`, error)
        systemStats.errors++
      }
    }
  })

  systemStats.messagesProcessed++
}

// Middleware ŸÑŸÑŸÖÿµÿßÿØŸÇÿ© ŸÅŸä Socket.IO
io.use((socket, next) => {
  const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.replace("Bearer ", "")

  if (!token) {
    console.warn("Socket.IO connection without token")
    return next() // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿØŸàŸÜ ŸÖÿµÿßÿØŸÇÿ© ŸÑŸÑÿ™ÿ∑ŸàŸäÿ±
  }

  const decoded = verifyToken(token)
  if (decoded) {
    socket.user = decoded
    console.log(`‚úÖ Authenticated Socket.IO user: ${decoded.id || decoded.username}`)
  } else {
    console.warn("Invalid token for Socket.IO connection")
  }

  next()
})

// ŸÖÿπÿßŸÑÿ¨ÿßÿ™ Socket.IO
io.on("connection", (socket) => {
  const clientId = generateClientId()
  systemStats.totalConnections++
  systemStats.activeConnections++

  console.log(`‚úÖ Socket.IO client connected: ${clientId} (${socket.id})`)

  // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿπŸÖŸäŸÑ
  socket.clientId = clientId
  socket.connectedAt = new Date()

  // ÿ•ÿ±ÿ≥ÿßŸÑ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿßÿ™ÿµÿßŸÑ
  socket.emit("connected", {
    clientId,
    serverId: "whatsapp-manager-ws",
    version: systemStats.version,
    timestamp: new Date().toISOString(),
    supportedEvents: [
      "device_status_changed",
      "qr_code_generated",
      "message_received",
      "message_sent",
      "device_connected",
      "device_disconnected",
      "system_stats",
    ],
  })

  // ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑÿ∫ÿ±ŸÅÿ© ÿ¨Ÿáÿßÿ≤ ŸÖÿ≠ÿØÿØ
  socket.on("join_device", (deviceId) => {
    if (deviceId) {
      socket.join(`device_${deviceId}`)
      socket.deviceId = deviceId
      console.log(`üì± Socket.IO client ${clientId} joined device room: ${deviceId}`)

      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿ≠ÿßŸÑŸäÿ©
      const deviceStatus = deviceStatuses.get(deviceId)
      if (deviceStatus) {
        socket.emit("device_status_changed", deviceStatus)
      }
    }
  })

  // ŸÖÿ∫ÿßÿØÿ±ÿ© ÿ∫ÿ±ŸÅÿ© ÿßŸÑÿ¨Ÿáÿßÿ≤
  socket.on("leave_device", (deviceId) => {
    if (deviceId) {
      socket.leave(`device_${deviceId}`)
      console.log(`üì± Socket.IO client ${clientId} left device room: ${deviceId}`)
    }
  })

  // ÿ∑ŸÑÿ® ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ
  socket.on("get_system_stats", () => {
    socket.emit("system_stats", {
      ...systemStats,
      uptime: Date.now() - systemStats.startTime.getTime(),
      connectedDevices: deviceStatuses.size,
      activeSocketConnections: io.engine.clientsCount,
      activeWSConnections: wss.clients.size,
      memory: process.memoryUsage(),
    })
  })

  // ÿ∑ŸÑÿ® ÿ≠ÿßŸÑÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ¨Ÿáÿ≤ÿ©
  socket.on("get_all_devices", () => {
    const devices = Array.from(deviceStatuses.entries()).map(([id, status]) => ({
      id,
      ...status,
    }))
    socket.emit("all_devices_status", devices)
  })

  // ping/pong ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ™ÿµÿßŸÑ
  socket.on("ping", () => {
    socket.emit("pong", { timestamp: new Date().toISOString() })
  })

  // ŸÖÿπÿßŸÑÿ¨ ŸÇÿ∑ÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑ
  socket.on("disconnect", (reason) => {
    systemStats.activeConnections--
    console.log(`‚ùå Socket.IO client disconnected: ${clientId} (${reason})`)
  })

  // ŸÖÿπÿßŸÑÿ¨ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
  socket.on("error", (error) => {
    systemStats.errors++
    console.error(`üö® Socket.IO error for client ${clientId}:`, error)
  })
})

// ŸÖÿπÿßŸÑÿ¨ÿßÿ™ WebSocket ÿßŸÑÿ™ŸÇŸÑŸäÿØŸä
wss.on("connection", (ws, req) => {
  const clientId = generateClientId()
  const clientIP = req.socket.remoteAddress

  systemStats.totalConnections++
  systemStats.activeConnections++

  console.log(`‚úÖ WebSocket client connected: ${clientId} from ${clientIP}`)

  // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿπŸÖŸäŸÑ
  connectedClients.set(clientId, {
    ws,
    clientId,
    connectedAt: new Date(),
    lastPing: new Date(),
    deviceId: null,
    ip: clientIP,
    authenticated: false,
  })

  // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ±ÿ≠Ÿäÿ®
  ws.send(
    JSON.stringify({
      event: "connected",
      data: {
        clientId,
        serverId: "whatsapp-manager-ws",
        version: systemStats.version,
        timestamp: new Date().toISOString(),
      },
    }),
  )

  // ŸÖÿπÿßŸÑÿ¨ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ
  ws.on("message", async (message) => {
    try {
      const data = JSON.parse(message.toString())
      const client = connectedClients.get(clientId)

      if (!client) return

      client.lastPing = new Date()

      switch (data.event) {
        case "authenticate":
          if (data.token) {
            const decoded = verifyToken(data.token)
            if (decoded) {
              client.authenticated = true
              client.user = decoded
              ws.send(
                JSON.stringify({
                  event: "authenticated",
                  data: { success: true, user: decoded },
                }),
              )
              console.log(`üîê WebSocket client ${clientId} authenticated as ${decoded.username}`)
            } else {
              ws.send(
                JSON.stringify({
                  event: "authentication_failed",
                  data: { error: "Invalid token" },
                }),
              )
            }
          }
          break

        case "ping":
          ws.send(JSON.stringify({ event: "pong", timestamp: new Date().toISOString() }))
          break

        case "join_device":
          if (data.deviceId) {
            client.deviceId = data.deviceId
            console.log(`üì± WebSocket client ${clientId} joined device: ${data.deviceId}`)

            // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿ≠ÿßŸÑŸäÿ©
            const deviceStatus = deviceStatuses.get(data.deviceId)
            if (deviceStatus) {
              ws.send(
                JSON.stringify({
                  event: "device_status_changed",
                  data: deviceStatus,
                }),
              )
            }
          }
          break

        case "get_system_stats":
          ws.send(
            JSON.stringify({
              event: "system_stats",
              data: {
                ...systemStats,
                uptime: Date.now() - systemStats.startTime.getTime(),
                connectedDevices: deviceStatuses.size,
                activeConnections: connectedClients.size,
                memory: process.memoryUsage(),
              },
            }),
          )
          break

        default:
          console.log(`üì® Received message from ${clientId}:`, data.event)
      }
    } catch (error) {
      systemStats.errors++
      console.error(`üö® Error processing message from ${clientId}:`, error)
    }
  })

  // ŸÖÿπÿßŸÑÿ¨ ŸÇÿ∑ÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑ
  ws.on("close", (code, reason) => {
    systemStats.activeConnections--
    connectedClients.delete(clientId)
    console.log(`‚ùå WebSocket client disconnected: ${clientId} (${code}: ${reason})`)
  })

  // ŸÖÿπÿßŸÑÿ¨ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
  ws.on("error", (error) => {
    systemStats.errors++
    console.error(`üö® WebSocket error for client ${clientId}:`, error)
  })
})

// API Routes ŸÑŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä WebSocket
app.get("/", (req, res) => {
  res.json({
    service: "WhatsApp Manager WebSocket Server",
    version: systemStats.version,
    status: "running",
    uptime: Date.now() - systemStats.startTime.getTime(),
    ubuntu: "24.04 LTS Support",
    endpoints: {
      health: "/health",
      stats: "/stats",
      broadcast: "/broadcast",
    },
  })
})

app.get("/health", (req, res) => {
  res.json({
    status: "healthy",
    version: systemStats.version,
    uptime: Date.now() - systemStats.startTime.getTime(),
    stats: {
      ...systemStats,
      socketIOConnections: io.engine.clientsCount,
      webSocketConnections: wss.clients.size,
      connectedDevices: deviceStatuses.size,
    },
    ubuntu: {
      supported: true,
      version: "24.04 LTS",
      nodeVersion: process.version,
      platform: process.platform,
      arch: process.arch,
    },
  })
})

app.get("/stats", (req, res) => {
  res.json({
    ...systemStats,
    uptime: Date.now() - systemStats.startTime.getTime(),
    connections: {
      socketIO: io.engine.clientsCount,
      webSocket: wss.clients.size,
      total: io.engine.clientsCount + wss.clients.size,
    },
    devices: Array.from(deviceStatuses.entries()).map(([id, status]) => ({
      id,
      ...status,
    })),
    memory: process.memoryUsage(),
  })
})

app.post("/broadcast", (req, res) => {
  try {
    const { event, data, deviceId } = req.body

    if (!event || !data) {
      return res.status(400).json({ error: "Event and data are required" })
    }

    if (deviceId) {
      broadcastToDevice(deviceId, event, data)
    } else {
      broadcastToAll(event, data)
    }

    res.json({ success: true, timestamp: new Date().toISOString() })
  } catch (error) {
    console.error("Broadcast error:", error)
    res.status(500).json({ error: "Internal server error" })
  }
})

// ÿØŸàÿßŸÑ ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿπÿßŸÖÿ©
function updateDeviceStatus(deviceId, status) {
  deviceStatuses.set(deviceId, {
    ...status,
    lastUpdated: new Date().toISOString(),
  })

  broadcastToAll("device_status_changed", {
    deviceId,
    ...status,
  })
}

function sendQRCode(deviceId, qrCode) {
  broadcastToDevice(deviceId, "qr_code_generated", {
    deviceId,
    qrCode,
    timestamp: new Date().toISOString(),
  })
}

function notifyMessage(deviceId, messageData) {
  broadcastToDevice(deviceId, "message_received", {
    deviceId,
    ...messageData,
    timestamp: new Date().toISOString(),
  })
}

// ÿ™ŸÜÿ∏ŸäŸÅ ÿØŸàÿ±Ÿä ŸÑŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿßŸÑŸÖŸÜŸÇÿ∑ÿπÿ©
setInterval(() => {
  const now = new Date()
  const timeout = 5 * 60 * 1000 // 5 ÿØŸÇÿßÿ¶ŸÇ

  connectedClients.forEach((client, clientId) => {
    if (now.getTime() - client.lastPing.getTime() > timeout) {
      console.log(`üßπ Cleaning up inactive client: ${clientId}`)
      if (client.ws && client.ws.readyState === WebSocket.OPEN) {
        client.ws.close(1000, "Timeout")
      }
      connectedClients.delete(clientId)
      systemStats.activeConnections--
    }
  })
}, 60000) // ŸÅÿ≠ÿµ ŸÉŸÑ ÿØŸÇŸäŸÇÿ©

// ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿØŸàÿ±Ÿäÿ©
setInterval(() => {
  const stats = {
    ...systemStats,
    uptime: Date.now() - systemStats.startTime.getTime(),
    connections: {
      socketIO: io.engine.clientsCount,
      webSocket: wss.clients.size,
      total: io.engine.clientsCount + wss.clients.size,
    },
    memory: process.memoryUsage(),
    timestamp: new Date().toISOString(),
  }

  broadcastToAll("system_stats", stats)
}, 30000) // ŸÉŸÑ 30 ÿ´ÿßŸÜŸäÿ©

// ŸÖÿπÿßŸÑÿ¨ÿ© ÿ•ÿ¥ÿßÿ±ÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ
process.on("SIGTERM", () => {
  console.log("üõë Received SIGTERM, shutting down gracefully...")
  server.close(() => {
    console.log("‚úÖ WebSocket server closed")
    process.exit(0)
  })
})

process.on("SIGINT", () => {
  console.log("üõë Received SIGINT, shutting down gracefully...")
  server.close(() => {
    console.log("‚úÖ WebSocket server closed")
    process.exit(0)
  })
})

// ÿ™ÿµÿØŸäÿ± ÿßŸÑÿØŸàÿßŸÑ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿä
global.wsServer = {
  updateDeviceStatus,
  sendQRCode,
  notifyMessage,
  broadcastToAll,
  broadcastToDevice,
  getStats: () => ({
    ...systemStats,
    uptime: Date.now() - systemStats.startTime.getTime(),
    connections: {
      socketIO: io.engine.clientsCount,
      webSocket: wss.clients.size,
    },
  }),
}

// ÿ®ÿØÿ° ÿßŸÑÿÆÿßÿØŸÖ
server.listen(PORT, "0.0.0.0", () => {
  console.log(`
üöÄ WhatsApp Manager WebSocket Server v${systemStats.version}
üì° Socket.IO + WebSocket Server running on port ${PORT}
üêß Ubuntu 24.04 LTS Support: ‚úÖ
üåê Environment: ${NODE_ENV}
üìä Health Check: http://localhost:${PORT}/health
üìà Stats: http://localhost:${PORT}/stats
‚è∞ Started at: ${new Date().toISOString()}
  `)
})

module.exports = { server, io, wss, updateDeviceStatus, sendQRCode, notifyMessage }
